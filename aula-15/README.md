# Aula 15

## Many to many com campos específicos

Ao usar o ManyToManyField do Django ele já cria automaticamente a tarceira tabela que relaciona Pedido e Livro. Mas podemos querer adicioanr alguma outra informação, como a quantidade de cada livro.

Nesse caso vamos especificar essa tabela manualmente e informar no campo many to many para usar esta tabela, através do parâmetro "through":

```python
from django.db import models

from clientes.models import Cliente
from livros.models import Livro


class Pedido(models.Model):
    cliente = models.ForeignKey(Cliente, on_delete=models.CASCADE, related_name='clientes_pedido')
    data = models.DateTimeField(auto_now_add=True)
    livros = models.ManyToManyField(Livro, through='PedidoLivros')

    def __str__(self):
        return f'{str(self.id)} - {self.cliente}'


class PedidoLivros(models.Model):
    pedido = models.ForeignKey(Pedido, on_delete=models.CASCADE)
    livro = models.ForeignKey(Livro, on_delete=models.CASCADE)
    quantidade = models.IntegerField(default=1)
```

Ao rodar o makemigrations, será gerado:

```python
# Generated by Django 4.2.2 on 2023-06-24 17:31

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ('livros', '0002_autor_livro_autor'),
        ('pedidos', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='PedidoLivros',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('quantidade', models.IntegerField(default=1)),
                ('livro', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='livros.livro')),
                ('pedido', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='pedidos.pedido')),
            ],
        ),
        migrations.AlterField(
            model_name='pedido',
            name='livros',
            field=models.ManyToManyField(through='pedidos.PedidoLivros', to='livros.livro'),
        ),
    ]
```

Ao tentar rodar o migrate acontecerá um erro:

```different
ValueError: Cannot alter field pedidos.Pedido.livros into pedidos.Pedido.livros - they are not compatible types (you cannot alter to or from M2M fields, or add or remove through= on M2M fields)
```

Vamos ajustar a migration, mudando de AlterField para RemoveField + AddField. Lembrando que ao fazer isso vamos perder os livros de pedidos que já existem (mas é possível tratar para que sejam preservados, caso seja um sistema em produção).

Agora é possível rodar a migration sem erros:

```python
# Generated by Django 4.2.2 on 2023-06-24 17:31

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ('livros', '0002_autor_livro_autor'),
        ('pedidos', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='PedidoLivros',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('quantidade', models.IntegerField(default=1)),
                ('livro', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='livros.livro')),
                ('pedido', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='pedidos.pedido')),
            ],
        ),
        migrations.RemoveField(
            model_name='pedido',
            name='livros',
        ),
        migrations.AddField(
            model_name='pedido',
            name='livros',
            field=models.ManyToManyField(through='pedidos.PedidoLivros', to='livros.livro'),
        ),
    ]
```

Ao abrir o admin e tentar cadastrar um pedido, o único campo que vai aparecer é o cliente. Para que os livros voltem a aparecer, vamos fazer o seguinte ajuste:

```python
from django.contrib import admin

from pedidos.models import Pedido, PedidoLivros


class PedidoLivrosInline(admin.TabularInline):
    model = PedidoLivros
    extra = 1


@admin.register(Pedido)
class PedidoAdmin(admin.ModelAdmin):
    list_display = ('id', 'cliente', 'data')
    inlines = [PedidoLivrosInline]
```

Também serão necessários ajustes no serializer:

```python
# criação dos serializers do PedidoLivros
class PedidoLivrosWriteSerializer(serializers.ModelSerializer):
    class Meta:
        model = PedidoLivros
        fields = ('livro', 'quantidade')


class PedidoLivrosReadSerializer(serializers.ModelSerializer):
    livro = LivroReadSerializer()

    class Meta:
        model = PedidoLivros
        fields = ('livro', 'quantidade')
```

Eles serão usados nos serializers do Pedido:

```python
class PedidoWriteSerializer(serializers.ModelSerializer):
    livros = PedidoLivrosWriteSerializer(source='pedidolivros_set', many=True)

    class Meta:
        model = Pedido
        fields = ('id', 'cliente', 'livros')


class PedidoReadSerializer(serializers.ModelSerializer):
    cliente = ClienteSerializer()
    livros = PedidoLivrosReadSerializer(source='pedidolivros_set', many=True)

    class Meta:
        model = Pedido
        fields = ('id', 'cliente', 'livros')
```

E também será necessário sobreescrever o create e update do PedidoWriteSerializer para criar cada PedidoLivros, isso não será feito automaticamente:

```python
class PedidoWriteSerializer(serializers.ModelSerializer):
    livros = PedidoLivrosSerializer(source='pedidolivros_set', many=True)

    class Meta:
        model = Pedido
        fields = ('id', 'cliente', 'livros')
    
    def create(self, validated_data):
        """
        O que chega:
        {
            "cliente": 1,
            "livros": [
                {
                    "livro": 1,
                    "quantidade": 2
                },
                {
                    "livro": 2,
                    "quantidade": 1
                }
            ]
        }
        """
        livros = validated_data.pop('pedidolivros_set')  # extrair os dados do json que chegaram na key livros
        instance = Pedido.objects.create(**validated_data)  # criar o Pedido
        for livro in livros: # para cada livro que chegou no json, criar um item PedidoLivros, vinculando com pedido e livro e adicionando a quantidade
            PedidoLivros.objects.create(pedido=instance, livro=livro.get('livro'), quantidade=livro.get('quantidade'))
        return instance # o create sempre deve retornar uma instância do model

    def update(self, instance, validated_data):
        livros = validated_data.pop('pedidolivros_set')
        instance.livros.clear() # quando for update o Pedido já existirá, mas precisamos remover qualquer livro que estava vinculado antes para deixar apenas os informados
        for livro in livros:
            PedidoLivros.objects.create(pedido=instance, livro=livro.get('livro'), quantidade=livro.get('quantidade'))
        return instance
```

Obs.: perceba que na linha 181 estamos extraindo os livros a partir de pedidolivros_set em vez de livros. Isso porque antes de chegar no create, os dados passam por um método is_valid(), que verifica se os dados que chegam são válidos e organiza eles em validated_data. Então livros vira pedidolivros_set. 

Com estas alterações já deve ser possível cadastrar pedidos normalmente pelo swagger.

## @property

Agora que temos o pedido com as quantidades de cada livro, podemos calcular o total do pedido. Para isso vamos precisar de um campo valor no Livro:

```python
class Livro(models.Model):
    titulo = models.CharField(max_length=255)
    ano = models.IntegerField()
    autor = models.ForeignKey(
        Autor, 
        related_name='livros_autor',  # o related_name é usado para recuperar os livros a partir do autor
        on_delete=models.CASCADE,  # se o autor for excluído o cascade vai fazer o livro ser excluído também
        null=True  # para evitar problema nos livros que foram criados antes da tabela Autor
    )
    valor = models.DecimalField(default=0, max_digits=10, decimal_places=2)  

    def __str__(self) -> str:
        return self.titulo
```

O novo campo é do tipo decimal, onde é preciso informar os atributos:
- decimal_places: casas depois da vírgula.
- max_digits: número máximo de dígitos, incluso os decimais.
Foi adicionado o default=0 para os livros que já existem e estão sem valor.

Depois, rodar o makemigrations e o migrate. Também lembrar de ajustar os serializers do livro para mostrar o valor.

Vamos criar no model Pedido uma property para calcular o total do pedido. Uma property é uma função que conseguimos acessar da mesma forma que um atributo da model:

```python
class Pedido(models.Model):
    cliente = models.ForeignKey(Cliente, on_delete=models.CASCADE, related_name='clientes_pedido')
    data = models.DateTimeField(auto_now_add=True)
    livros = models.ManyToManyField(Livro, through='PedidoLivros')

    @property
    def total(self):
        total = 0
        for livro in self.livros.all():
            livro_pedido = PedidoLivros.objects.get(pedido=self, livro=livro)
            valor = livro.valor
            quantidade = livro_pedido.quantidade
            total += valor * quantidade
        return total

    def __str__(self):
        return f'{str(self.id)} - {self.cliente}'
```

Ela pode ser chamada no serializer apenas passando "total" nos fields:

```python
class PedidoReadSerializer(serializers.ModelSerializer):
    cliente = ClienteSerializer()
    livros = PedidoLivrosReadSerializer(source='pedidolivros_set', many=True)

    class Meta:
        model = Pedido
        fields = ('id', 'cliente', 'livros', 'total')
```

Para testar, adicionar valores aos livros usados no pedido e chamar o GET Pedidos.